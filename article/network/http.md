# HTTP 的工作原理是什么

## HTTP基本概念

- 网络由下往上可以分为
  物理层、数据链路层、网络层、传输层、会话层、表示层和应用层

- 通过初步的了解，可以知道
  **IP协议**对应于**网络层**，**TCP协议**对应于**传输层**，而**HTTP协议**对应于**应用层**

- **HTTP连接**等于以**HTTP协议**为通信协议的**TCP连接**

## HTTP/0.9

最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。

```bash
GET /index.html
```

上面命令表示，**TCP 连接**（connection）建立后，客户端向服务器**请求**（request）网页index.html。

协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。

```xml
<html>
  <body>Hello World</body>
</html>
```

服务器发送完毕，就关闭TCP连接。

## HTTP/1.0

1996年5月，HTTP/1.0 版本发布，内容大大增加

首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。

其次，除了`GET`命令，还引入了`POST`命令和`HEAD`命令，丰富了浏览器与服务器的互动手段。

再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。

其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。

- 请求格式
  下面是一个1.0版的HTTP请求的例子。

  ```bash
  GET / HTTP/1.0
  User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
  Accept: */*
  ```

可以看到，这个格式与0.9版有很大变化。
第一行是请求命令，必须在尾部添加协议版本（HTTP/1.0）。后面就是多行头信息，描述客户端的情况

- 回应格式
  服务器的回应如下。

  ```bash
  HTTP/1.0 200 OK
  Content-Type: text/plain
  Content-Length: 137582
  Expires: Thu, 05 Dec 1997 16:00:00 GMT
  Last-Modified: Wed, 5 August 1996 15:55:28 GMT
  Server: Apache 0.84
  ```

  ```xml
  <html>
    <body>Hello World</body>
  </html>
  ```

回应的格式是"头信息 + 一个空行（`\r\n`） + 数据"。其中，第一行是"协议版本 + 状态码（status code） + 状态描述"。

## HTTP/1.1

1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。

- 持久连接
  1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive

  客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。

  ```bash
  Connection: close
  ```

  目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。

- 管道机制
  1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率
  
  举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。
  
## HTTP工作原理

1. 地址解析
  如用客户端浏览器请求这个页面：<http://localhost.com:8080/index.htm>
  从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：

    ```bash
      协议名：http
      主机名：localhost.com
      端口：8080
      对象路径：/index.htm
    ```

    在这一步，需要域名系统DNS解析域名localhost.com，得到主机的IP地。

2. 封装HTTP请求数据包
  把以上部分结合本机自己的信息，封装成一个HTTP请求数据包

3. 封装成TCP包，建立TCP连接（TCP的三次握手）
  在HTTP工作开始之前，客户机（Web浏览器）首先要通过网络与服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络
  HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。这里是8080端

4. 客户机发送请求命令
  建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可内容

5. 服务器响应
  服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。
  实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据

6. 服务器关闭TCP连接
  一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码

  ```bash
  Connection:keep-alive
  ```

  TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽

## HTTP 协议和服务器交互的方法

1. GET：获取资源
  GET方法用来请求访问已被URL识别的资源
  
2. POST：传输实体主体
  POST方法用来请求服务器传输信息实体的主体

3. PUT：传输文件
  PUT要求在请求报文的主体中包含文件内容，然后保存到请求URL指定的位置
  处于安全考虑，一般web网站不使用此方法，若配合web的安全验证机制，或者架构采用REST标准的网站，就可能开放使用此方法

4. HEAD：获得报文首部
  HEAD和GET方法一样，只不过不返回报文主体部分，用于确认URI的有效性及资源更新的日期时间等

5. DELETE：删除文件
  DELETE是与PUT相反的方法，是按请求URI删除指定的资源
  处于安全考虑，一般web网站不使用此方法，若配合web的安全验证机制，或者架构采用REST标准的网站，就可能开放使用此方法

6. OPYIONS：询问支持的方法
  用来查询针对请求URI指定的资源支持的方法

7. TRACE：追踪路径
  是让web服务器端将之前的请求通信还回给客户端的方法
  发送请求时，在Max-Frowards首部字段中填入数值，每经过一个服务器端就-1，当数值为0时，停止传输，最后收到服务器返回状态码200 OK的响应
  但是，这种方法基本很少使用，而且很容易引起XST（跨站追踪）攻击，就更不会用到了。

8. CONNECT：要求采用隧道协议连接代理
  该方法要求在于代理服务器通信时建立隧道，实现用隧道协议进行TCP通信，主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经过网络传输。

## 状态码200，301，304，403，404，500，503分别代表什么意思

- **1xx（临时响应）  **
  表示临时响应并需要请求者继续执行操作的状态代码。
  
  |代码|说明|
  |-|-|  
  |100（继续）|请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分|
  |101（切换协议） |请求者已要求服务器切换协议，服务器已确认并准备切换|
  
- **2xx （成功）**  
  表示成功处理了请求的状态代码。

  |代码 |  说明|
  |-|-|  
  |**200（成功）** | 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页|  
  |201（已创建）|  请求成功并且服务器创建了新的资源|  
  |202（已接受）|  服务器已接受请求，但尚未处理|  
  |203（非授权信息）|  服务器已成功处理了请求，但返回的信息可能来自另一来源|
  |204（无内容）|服务器成功处理了请求，但没有返回任何内容|
  |205（重置内容）| 服务器成功处理了请求，但没有返回任何内容|
  |206（部分内容）|  服务器成功处理了部分 GET 请求|

- **3xx （重定向） **
  表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。

  |代码|说明|
  |-|-|  
  |300   （多种选择）|针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择|
  |**301（永久移动）** | 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置|  
  |302（临时移动）|  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求|  
  |303（查看其他位置）| 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码|  
  |**304（未修改）**| 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容|  
  |305（使用代理）| 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理|  
  |307（临时重定向） | 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求|

- **4xx （请求错误）**
  这些状态代码表示请求可能出错，妨碍了服务器的处理。

  |代码|说明|
  |-|-|  
  |400（错误请求）|服务器不理解请求的语法 |
  |401（未授权）|请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应 |
  |**403（禁止）**|服务器拒绝请求|
  |**404（未找到）**|服务器找不到请求的网页 |
  |405（方法禁用）|禁用请求中指定的方法|
  |406（不接受）|无法使用请求的内容特性响应请求的网页|  
  |407（需要代理授权）|此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理|
  |408（请求超时）|服务器等候请求时发生超时|
  |409（冲突）|服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息|
  |410（已删除）|如果请求的资源已永久删除，服务器就会返回此响应|
  |411（需要有效长度）|服务器不接受不含有效内容长度标头字段的请求|
  |412（未满足前提条件）|服务器未满足请求者在请求中设置的其中一个前提条件|
  |413（请求实体过大）|服务器无法处理请求，因为请求实体过大，超出服务器的处理能力|
  |414（请求的 URI 过长）|请求的 URI（通常为网址）过长，服务器无法处理|
  |415（不支持的媒体类型）|请求的格式不受请求页面的支持|
  |416（请求范围不符合要求）|如果页面无法提供请求的范围，则服务器会返回此状态代码|
  |417（未满足期望值）|服务器未满足”期望”请求标头字段的要求|

- **5xx（服务器错误）**
  这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。

  |代码|说明|
  |-|-|
  |**500（服务器内部错误）**|服务器遇到错误，无法完成请求|
  |501（尚未实施）|服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码|
  |502（错误网关）|服务器作为网关或代理，从上游服务器收到无效响应|
  |**503（服务不可用）**|服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态|
  |504（网关超时）|服务器作为网关或代理，但是没有及时从上游服务器收到请求|
  |505（HTTP 版本不受支持）|服务器不支持请求中所用的 HTTP 协议版本|

## 报文有哪几部分组成？\

![报文有哪几部分组成](/assets/message.png)
如图所示，由请求行，头部，空行，内容四部分组成

> 引用 <http://blog.csdn.net/hguisu/article/details/8680808>